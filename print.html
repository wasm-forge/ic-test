<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Enabling SQLite in canisters with &#x60;ic-ruslite&#x60;</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the &#x60;ic-rusqlite&#x60; convenience package">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Enabling SQLite in canisters with &#x60;ic-ruslite&#x60;</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wasm-forge/ic-rusqlite" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>ic-test</strong> is a command-line tool that helps to set up and manage Rust canister tests on the Internet Computer (IC).
The tool makes it easier to create a test project and includes the basic files and setup needed for both IC canisters and optionally EVM (Ethereum Virtual Machine) smart contracts.</p>
<p>The tool reads the <code>dfx.json</code> (must exist) and the <code>foundry.toml</code> (may exist) files in order to build the test environment automatically. It uses <code>pocket-ic</code> and <code>alloy</code> (foundry) to run tests.
The generated code and helpers provide:</p>
<ul>
<li>A simple way to start a test project.</li>
<li>A single, easy-to-use interface for testing IC Canisters and EVM smart contracts.</li>
<li>Type checking and auto-completion support.</li>
<li>Easy functions for deploying and calling canisters or contracts.</li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><strong>ic-test</strong> will:</p>
<ul>
<li>Read <code>dfx.json</code> to get canister details.</li>
<li>Read <code>foundry.toml</code> to get contract details.</li>
<li>Generate Rust types from Candid (<code>.did</code>) files.</li>
<li>Generate contract interfaces from Solidity (<code>.sol</code>) files.</li>
<li>Provide API to work with <code>.wasm</code> canisters and <code>.json</code> contract files in tests.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Rust</a></li>
<li><a href="https://internetcomputer.org/docs/building-apps/getting-started/install#installing-dfx-via-dfxvm">DFX</a> – to build and locally deploy canisters.</li>
<li><a href="https://book.getfoundry.sh/getting-started/installation">Foundry</a> – optional, if you want to test EVM contract's interaction with canisters.</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Install the <code>ic-test</code> CLI tool:</p>
<pre><code class="language-bash">cargo install ic-test
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-options"><a class="header" href="#command-line-options">Command line options</a></h1>
<h2 id="tool-usage"><a class="header" href="#tool-usage">Tool usage</a></h2>
<pre><code class="language-bash">ic-test &lt;COMMAND&gt; [OPTIONS]
</code></pre>
<p>Without arguments it starts in interactive mode to create a new test project. If an <code>ic-test.json</code> config file exists already, the <code>update</code> mode will regenerate the existing test project bindings.</p>
<h3 id="create-a-new-test-project"><a class="header" href="#create-a-new-test-project">Create a new test project</a></h3>
<pre><code class="language-bash">ic-test new tests
</code></pre>
<ul>
<li>Creates a new test project in the <code>tests</code> folder.</li>
<li>Looks for canisters and contracts, generates API bindings and a sample test.</li>
<li>Generates an <code>ic-test.json</code> configuration file.</li>
<li>Fails if the <code>tests</code> folder already exists, the user would need to choose a different name.</li>
</ul>
<h3 id="updateregenerate-an-existing-test-project"><a class="header" href="#updateregenerate-an-existing-test-project">Update/regenerate an existing test project</a></h3>
<pre><code class="language-bash">ic-test update
</code></pre>
<p>Regenerates bindings using the configuration in <code>ic-test.json</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>Here are some tutorials demonstrating how to create the test projects with the <code>ic-test</code> tool.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counter-tutorial"><a class="header" href="#counter-tutorial">"Counter" Tutorial</a></h1>
<p>Let's create a simple project and test it using the <code>ic-test</code>.</p>
<p><em>Create a "Hello, World!" canister:</em></p>
<pre><code class="language-bash">dfx new hello-ic-test --type rust --no-frontend
</code></pre>
<p><em>Compile the project:</em></p>
<pre><code class="language-bash">dfx start --clean --background

dfx canister create --all

dfx build
</code></pre>
<p><em>Generate test bindings</em></p>
<p>If there are uncommitted changes, either commit them before generating or use the <code>--force</code> flag:</p>
<pre><code class="language-bash">ic-test new tests --force
</code></pre>
<p>This creates a tests package with:</p>
<ul>
<li>Canister API bindings in <code>tests/src/bindings</code></li>
<li>Test environment setup logic in <code>test_setup.rs</code></li>
<li>A test template in <code>tests.rs</code></li>
</ul>
<h3 id="example-test"><a class="header" href="#example-test">Example test</a></h3>
<p><em>Edit <code>tests.rs</code>:</em></p>
<pre><code class="language-rust ignore">use ic_test::IcpTest;

use crate::test_setup;

#[tokio::test]
async fn test_greet() {
    let test_setup::Env {
        icp_test,
        hello_ic_test_backend,
    } = test_setup::setup(IcpTest::new().await).await;

    let result = hello_ic_test_backend
        .greet("ic-test".to_string())
        .call()
        .await;

    assert_eq!(result, "Hello, ic-test!");
}</code></pre>
<p><em>Run tests:</em></p>
<pre><code class="language-bash">cargo test
</code></pre>
<h3 id="adding-a-counter"><a class="header" href="#adding-a-counter">Adding a counter</a></h3>
<p><em>Update the canister backend:</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

#[ic_cdk::query]
fn greet(name: String) -&gt; String {
    format!("Hello, {}!", name)
}

#[derive(Clone, Default)]
struct CounterState {
    value: u64,
    increment: u64,
}

thread_local! {
    static STATE: RefCell&lt;CounterState&gt; = RefCell::new(CounterState::default());
}

#[ic_cdk::init]
fn init(init_value: u64, increment: u64) {
    STATE.with(|state| {
        *state.borrow_mut() = CounterState {
            value: init_value,
            increment,
        };
    });
}

#[ic_cdk::update]
fn increment_counter() {
    STATE.with(|state| {
        let mut s = state.borrow_mut();
        s.value += s.increment;
    });
}

#[ic_cdk::query]
fn get_counter() -&gt; u64 {
    STATE.with(|state| state.borrow().value)
}
<span class="boring">}</span></code></pre></pre>
<p><em>Update Candid file <code>hello-ic-test-backend.did</code>:</em></p>
<pre><code class="language-candid">service : (nat64, nat64) -&gt; {
  "greet": (text) -&gt; (text) query;
  "get_counter": () -&gt; (nat64) query;
  "increment_counter": () -&gt; ();
}
</code></pre>
<p><em>Set initialization arguments in <code>dfx.json</code>:</em></p>
<pre><code class="language-json">{
  "canisters": {
    "hello-ic-test-backend": {
      "candid": "src/hello-ic-test-backend/hello-ic-test-backend.did",
      "package": "hello-ic-test-backend",
      "type": "rust",
      "init_arg": "(50, 73)"
    }
  },
  "defaults": {
    "build": {
      "args": "",
      "packtool": ""
    }
  },
  "output_env_file": ".env",
  "version": 1
}
</code></pre>
<p><em>Regenerate the bindings:</em></p>
<pre><code class="language-bash">dfx build

ic-test
</code></pre>
<p>The <code>ic-test</code> will enter interactive mode and prompt user to allow overwriting the <code>test_setup.rs</code> file. Upon confirmation the the <code>test_setup.rs</code> is regenerated with the initialization parameters:</p>
<pre><code class="language-rust ignore">//...
    let hello_ic_test_backend = hello_ic_test_backend::deploy(&amp;icp_user, 50, 73)
        .call()
        .await;

// ...
</code></pre>
<h3 id="new-test"><a class="header" href="#new-test">New test</a></h3>
<p><em>Add a new test in <code>tests.rs</code>:</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_counter() {
    let test_setup::Env {
        icp_test,
        hello_ic_test_backend,
    } = test_setup::setup(IcpTest::new().await).await;

    let result = hello_ic_test_backend.get_counter().call().await;

    assert_eq!(result, 50u64);

    hello_ic_test_backend.increment_counter().call().await;

    let result = hello_ic_test_backend.get_counter().call().await;

    assert_eq!(result, 123u64); // 50 + 73
}
<span class="boring">}</span></code></pre></pre>
<p><em>Run tests:</em></p>
<pre><code class="language-bash">cargo test
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evm-rpc-integration"><a class="header" href="#evm-rpc-integration">EVM RPC Integration</a></h1>
<h2 id="initial-preparations"><a class="header" href="#initial-preparations">Initial preparations</a></h2>
<p>In this examples we'll explore testing a canister that uses integration with the Ethereum smart contracts and will see how one can create canister, EVM or the hybrid tests.</p>
<p>For a quick start, clone the <a href="https://github.com/wasm-forge/ic-test-examples"><code>ic-test-examples</code></a> repository and enter the <code>eth-balance</code> project:</p>
<pre><code class="language-bash">git clone https://github.com/wasm-forge/ic-test-examples.git
cd ic-test-examples/eth-balance
</code></pre>
<p>In the cloned examples repository enter the project <code>eth-balance</code>. It is a basic implementation of a canister that connects to an EVM-RPC service and requests for a current Eth balance on any Ethereum address. You can try deploy it and see that the canister actually works ( and start <code>dfx</code> if it not running already):</p>
<pre><code class="language-bash">dfx start --background --clean
dfx deploy
</code></pre>
<p>Now, call the canister to request balance of some Eth account:</p>
<pre><code class="language-bash">dfx canister call eth-balance-backend get_eth_balance '("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")'
</code></pre>
<p>This project already has the <code>ic-test</code> integration. You can make sure the test project is working by launching tests, but in order to deploy smart contracts that are part of the tests, you need to build them:</p>
<pre><code class="language-bash">cd evm
forge build
cd ..

cargo test
</code></pre>
<p>If the project compiles and tests are green, you have successfully tested canister communication with the local Anvil node containing custom smart contracts.</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project structure</a></h2>
<pre><code>eth-balance
├── Cargo.lock
├── Cargo.toml
├── dfx.json                 # `dfx` contiguration.
├── evm
│   ├── foundry.toml         # The toml file used by ic-test to gather existing smart contracts.
│   ├── lib                  # Forge standard library.
│   │   └── ...
│   ├── out                  # Compiled smart contracts.
│   │   └── ...
│   ├── script             
│   │   ├── Counter.s.sol    # Smart contract installation scripts.
│   │   └── Sender.s.sol
│   ├── src                  # Smart contract source files.
│   │   ├── Counter.sol
│   │   └── Sender.sol
│   ├── test_counter.sh      # example shell scripts to test smart contracts from the command line using `anvil` and `cast`.
│   └── test_sender.sh
├── ic-test.json             # ic-test configuration what can be used to regenerate the test project.
├── README.md                # 
├── src                      
│   └── eth-balance-backend  # eth-balance canister backend source.
│       ├── Cargo.toml
│       ├── eth-balance-backend.did  # The candid file used to generate canister bindings.
│       └── src
│           └── lib.rs
└── tests                    # Test project created by the `ic-test`.
    ├── Cargo.toml           
    └── src
        ├── bindings         # Canister and smart contract bindings generated by the `ic-test`
        │   ├── eth_balance_backend.rs
        │   ├── evm_rpc.rs
        │   └── mod.rs
        ├── lib.rs           
        ├── test_setup.rs    # Test preparation.
        └── tests.rs         # Actual tests that will be run on `cargo test`.
</code></pre>
<p>The <code>evm</code> folder contains an EVM Forge project that was created with <code>forge init evm</code>. You can find there the initial contract <code>Counter.sol</code>. It is a "counter" example that can
initialize its counter value and increment it. The second contract is the <code>Sender.sol</code>, it can transfer its Ethereum to any given address.</p>
<p><em>Sender contract</em></p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Sender {
    address public owner;

    constructor() {
        owner = msg.sender; // Set the contract deployer as the owner
    }

    // Function to receive Ether. Required for the contract to accept ETH.
    receive() external payable {}

    // Send Ether from the contract to a recipient, the function is payable so that we can send the money along the call
    function sendEther(address payable receiver, uint256 eth) external payable {
        require(msg.sender == owner, "Only owner can send Ether");
        require(address(this).balance &gt;= eth, "Insufficient balance");

        (bool sent, ) = receiver.call{value: eth}("");
        require(sent, "Failed to send Ether");
    }

    // Check contract balance
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
</code></pre>
<h2 id="creating-a-new-test-project"><a class="header" href="#creating-a-new-test-project">Creating a new test project</a></h2>
<p>In this tutorial we want to create our own test project using the <code>ic-test</code> tool.
We can trick the <code>ic-test</code> tool to think that there is no test project by deleting or renaming the <code>ic-test.json</code>:</p>
<pre><code class="language-bash">rm ic-test.json
</code></pre>
<p>Now, to create the test project named <code>my-tests</code>, enter:</p>
<pre><code class="language-bash">ic-test new my-tests
</code></pre>
<p>This will create a new test project and add it to the workspace:</p>
<pre><code>my-tests
├── Cargo.toml
└── src
    ├── bindings
    │   ├── eth_balance_backend.rs
    │   ├── evm_rpc.rs
    │   └── mod.rs
    ├── lib.rs
    ├── test_setup.rs
    └── tests.rs
</code></pre>
<p>You can check the <code>ic-test.json</code> to see which canisters and contracts were found and their respective file locations:</p>
<pre><code class="language-json">{
  "test_folder": "my-tests",
  "icp_setup": {
    "dfx_json": "dfx.json",
    "skip_dfx_json": false,
    "canisters": {
      "eth-balance-backend": {
        "name": "eth-balance-backend",
        "var_name": "eth_balance_backend",
        "service_name": "EthBalanceBackendCanister",
        "candid_path": "src/eth-balance-backend/eth-balance-backend.did",
        "generate_bindings": true,
        "wasm": "target/wasm32-unknown-unknown/release/eth_balance_backend.wasm",
        "specified_id": null
      },
      "evm_rpc": {
        "name": "evm_rpc",
        "var_name": "evm_rpc",
        "service_name": "EvmRpcCanister",
        "candid_path": ".dfx/local/canisters/evm_rpc/constructor.did",
        "init_arg": "(record {})",
        "generate_bindings": true,
        "wasm": ".dfx/local/canisters/evm_rpc/evm_rpc.wasm.gz",
        "specified_id": "7hfb6-caaaa-aaaar-qadga-cai"
      }
    }
  },
  "evm_setup": {
    "foundry_toml_path": "./evm",
    "skip_foundry_toml": false,
    "foundry_src": "src",
    "foundry_out": "out",
    "contracts": {
      "Counter": {
        "name": "Counter",
        "var_name": "counter",
        "sol_json": "./evm/out/Counter.sol/Counter.json"
      },
      "Sender": {
        "name": "Sender",
        "var_name": "sender",
        "sol_json": "./evm/out/Sender.sol/Sender.json"
      }
    }
  }
}
</code></pre>
<p>Edit the <code>src/tests.rs</code> file, and add a new test:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//...
#[tokio::test]
async fn test_eth_transfer() {
    let env = test_setup::setup(IcpTest::new().await).await;

    let address1 = env.evm_user.address;
    let destination_address = env.icp_test.evm.test_user(1).address;

    let result = env
        .eth_balance_backend
        .get_eth_balance(address1.to_string())
        .call()
        .await;

    let eth = parse_ether(&amp;result).unwrap();

    // assert the main user still has around 10000 Ether after deploying contracts
    assert!(parse_ether("10000").unwrap() - eth &lt; parse_ether("0.01").unwrap());

    let result = env
        .eth_balance_backend
        .get_eth_balance(destination_address.to_string())
        .call()
        .await;

    // assert the second user has exactly 10000 Eth (the initial test value)
    assert_eq!(result, "10000");

    // prepare payment to send via the Sender contract
    let payment = parse_ether("100.01").unwrap();

    // The amount we want to send
    let amount_to_send = parse_ether("100.0").unwrap();

    // call Sender.sendEther
    let receipt = env
        .sender
        .sendEther(destination_address, amount_to_send)
        .value(payment)
        .send()
        .await
        .unwrap()
        .get_receipt()
        .await
        .unwrap();

    assert!(receipt.status());

    let result = env
        .eth_balance_backend
        .get_eth_balance(destination_address.to_string())
        .call()
        .await;

    // assert the second user has now 10100 Eth
    assert_eq!(result, "10100");
}

<span class="boring">}</span></code></pre></pre>
<p>In this test you are using the <code>eth_balance_backend</code> canister to read Ether value from the first and second Anvil users (their initial wallets contain 10000.0 Ethers, but the first user has slightly less because some amount was spent to deploy the <code>Sender</code> and <code>Counter</code> contracts).</p>
<p>Then 100 Ethers are transfered from the first user to the second user with the <code>Sender</code> smart contract. The final value of the second account is expected to be 10100 Ethers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(result, "10100");
<span class="boring">}</span></code></pre></pre>
<p>You can change the last assertion to see that the test fails if the value is wrong.</p>
<p><em>Note:</em> the <code>sendEther</code> contract is executed via <code>send</code> command because it executes a transaction and changes the state of the network, this also costs a bit of Ethereum, hence the <code>value()</code> call adds the amount to send and a little extra Ethereum for the contract to run.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
